// Generated by gencpp from file conti_radar/radar_obj.msg
// DO NOT EDIT!


#ifndef CONTI_RADAR_MESSAGE_RADAR_OBJ_H
#define CONTI_RADAR_MESSAGE_RADAR_OBJ_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace conti_radar
{
template <class ContainerAllocator>
struct radar_obj_
{
  typedef radar_obj_<ContainerAllocator> Type;

  radar_obj_()
    : id(0)
    , f_DistX()
    , f_DistY()
    , f_VrelX()
    , f_VrelY()
    , f_ArelX()
    , f_ArelY()
    , f_DistXStd()
    , f_DistYStd()
    , f_VrelXStd()
    , f_VrelYStd()
    , f_ArelXStd()
    , f_ArelYStd()
    , f_LDeltaX_left()
    , f_LDeltaX_mid()
    , f_LDeltaX_right()
    , f_LDeltaY_left()
    , f_LDeltaY_mid()
    , f_LDeltaY_right()
    , f_RCS()
    , f_ObjectScore()
    , f_VabsX()
    , f_VabsY()
    , f_AabsX()
    , f_AabsY()
    , f_VabsXStd()
    , f_VabsYStd()
    , f_AabsXStd()
    , f_AabsYStd()
    , f_Orientation()
    , f_OrientationStd()
    , f_DistZ()
    , f_DistZStd()  {
    }
  radar_obj_(const ContainerAllocator& _alloc)
    : id(0)
    , f_DistX(_alloc)
    , f_DistY(_alloc)
    , f_VrelX(_alloc)
    , f_VrelY(_alloc)
    , f_ArelX(_alloc)
    , f_ArelY(_alloc)
    , f_DistXStd(_alloc)
    , f_DistYStd(_alloc)
    , f_VrelXStd(_alloc)
    , f_VrelYStd(_alloc)
    , f_ArelXStd(_alloc)
    , f_ArelYStd(_alloc)
    , f_LDeltaX_left(_alloc)
    , f_LDeltaX_mid(_alloc)
    , f_LDeltaX_right(_alloc)
    , f_LDeltaY_left(_alloc)
    , f_LDeltaY_mid(_alloc)
    , f_LDeltaY_right(_alloc)
    , f_RCS(_alloc)
    , f_ObjectScore(_alloc)
    , f_VabsX(_alloc)
    , f_VabsY(_alloc)
    , f_AabsX(_alloc)
    , f_AabsY(_alloc)
    , f_VabsXStd(_alloc)
    , f_VabsYStd(_alloc)
    , f_AabsXStd(_alloc)
    , f_AabsYStd(_alloc)
    , f_Orientation(_alloc)
    , f_OrientationStd(_alloc)
    , f_DistZ(_alloc)
    , f_DistZStd(_alloc)  {
  (void)_alloc;
    }



   typedef int32_t _id_type;
  _id_type id;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistX_type;
  _f_DistX_type f_DistX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistY_type;
  _f_DistY_type f_DistY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VrelX_type;
  _f_VrelX_type f_VrelX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VrelY_type;
  _f_VrelY_type f_VrelY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_ArelX_type;
  _f_ArelX_type f_ArelX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_ArelY_type;
  _f_ArelY_type f_ArelY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistXStd_type;
  _f_DistXStd_type f_DistXStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistYStd_type;
  _f_DistYStd_type f_DistYStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VrelXStd_type;
  _f_VrelXStd_type f_VrelXStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VrelYStd_type;
  _f_VrelYStd_type f_VrelYStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_ArelXStd_type;
  _f_ArelXStd_type f_ArelXStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_ArelYStd_type;
  _f_ArelYStd_type f_ArelYStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaX_left_type;
  _f_LDeltaX_left_type f_LDeltaX_left;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaX_mid_type;
  _f_LDeltaX_mid_type f_LDeltaX_mid;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaX_right_type;
  _f_LDeltaX_right_type f_LDeltaX_right;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaY_left_type;
  _f_LDeltaY_left_type f_LDeltaY_left;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaY_mid_type;
  _f_LDeltaY_mid_type f_LDeltaY_mid;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_LDeltaY_right_type;
  _f_LDeltaY_right_type f_LDeltaY_right;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_RCS_type;
  _f_RCS_type f_RCS;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_ObjectScore_type;
  _f_ObjectScore_type f_ObjectScore;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VabsX_type;
  _f_VabsX_type f_VabsX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VabsY_type;
  _f_VabsY_type f_VabsY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_AabsX_type;
  _f_AabsX_type f_AabsX;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_AabsY_type;
  _f_AabsY_type f_AabsY;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VabsXStd_type;
  _f_VabsXStd_type f_VabsXStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_VabsYStd_type;
  _f_VabsYStd_type f_VabsYStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_AabsXStd_type;
  _f_AabsXStd_type f_AabsXStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_AabsYStd_type;
  _f_AabsYStd_type f_AabsYStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_Orientation_type;
  _f_Orientation_type f_Orientation;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_OrientationStd_type;
  _f_OrientationStd_type f_OrientationStd;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistZ_type;
  _f_DistZ_type f_DistZ;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _f_DistZStd_type;
  _f_DistZStd_type f_DistZStd;





  typedef boost::shared_ptr< ::conti_radar::radar_obj_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::conti_radar::radar_obj_<ContainerAllocator> const> ConstPtr;

}; // struct radar_obj_

typedef ::conti_radar::radar_obj_<std::allocator<void> > radar_obj;

typedef boost::shared_ptr< ::conti_radar::radar_obj > radar_objPtr;
typedef boost::shared_ptr< ::conti_radar::radar_obj const> radar_objConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::conti_radar::radar_obj_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::conti_radar::radar_obj_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::conti_radar::radar_obj_<ContainerAllocator1> & lhs, const ::conti_radar::radar_obj_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.f_DistX == rhs.f_DistX &&
    lhs.f_DistY == rhs.f_DistY &&
    lhs.f_VrelX == rhs.f_VrelX &&
    lhs.f_VrelY == rhs.f_VrelY &&
    lhs.f_ArelX == rhs.f_ArelX &&
    lhs.f_ArelY == rhs.f_ArelY &&
    lhs.f_DistXStd == rhs.f_DistXStd &&
    lhs.f_DistYStd == rhs.f_DistYStd &&
    lhs.f_VrelXStd == rhs.f_VrelXStd &&
    lhs.f_VrelYStd == rhs.f_VrelYStd &&
    lhs.f_ArelXStd == rhs.f_ArelXStd &&
    lhs.f_ArelYStd == rhs.f_ArelYStd &&
    lhs.f_LDeltaX_left == rhs.f_LDeltaX_left &&
    lhs.f_LDeltaX_mid == rhs.f_LDeltaX_mid &&
    lhs.f_LDeltaX_right == rhs.f_LDeltaX_right &&
    lhs.f_LDeltaY_left == rhs.f_LDeltaY_left &&
    lhs.f_LDeltaY_mid == rhs.f_LDeltaY_mid &&
    lhs.f_LDeltaY_right == rhs.f_LDeltaY_right &&
    lhs.f_RCS == rhs.f_RCS &&
    lhs.f_ObjectScore == rhs.f_ObjectScore &&
    lhs.f_VabsX == rhs.f_VabsX &&
    lhs.f_VabsY == rhs.f_VabsY &&
    lhs.f_AabsX == rhs.f_AabsX &&
    lhs.f_AabsY == rhs.f_AabsY &&
    lhs.f_VabsXStd == rhs.f_VabsXStd &&
    lhs.f_VabsYStd == rhs.f_VabsYStd &&
    lhs.f_AabsXStd == rhs.f_AabsXStd &&
    lhs.f_AabsYStd == rhs.f_AabsYStd &&
    lhs.f_Orientation == rhs.f_Orientation &&
    lhs.f_OrientationStd == rhs.f_OrientationStd &&
    lhs.f_DistZ == rhs.f_DistZ &&
    lhs.f_DistZStd == rhs.f_DistZStd;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::conti_radar::radar_obj_<ContainerAllocator1> & lhs, const ::conti_radar::radar_obj_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace conti_radar

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::conti_radar::radar_obj_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::conti_radar::radar_obj_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::conti_radar::radar_obj_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::conti_radar::radar_obj_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::conti_radar::radar_obj_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::conti_radar::radar_obj_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::conti_radar::radar_obj_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d139e1dca278064cbcdfddd5e7dfb3bb";
  }

  static const char* value(const ::conti_radar::radar_obj_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd139e1dca278064cULL;
  static const uint64_t static_value2 = 0xbcdfddd5e7dfb3bbULL;
};

template<class ContainerAllocator>
struct DataType< ::conti_radar::radar_obj_<ContainerAllocator> >
{
  static const char* value()
  {
    return "conti_radar/radar_obj";
  }

  static const char* value(const ::conti_radar::radar_obj_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::conti_radar::radar_obj_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 id\n"
"float32[] f_DistX\n"
"float32[] f_DistY\n"
"float32[] f_VrelX\n"
"float32[] f_VrelY\n"
"float32[] f_ArelX\n"
"float32[] f_ArelY\n"
"float32[] f_DistXStd\n"
"float32[] f_DistYStd\n"
"float32[] f_VrelXStd\n"
"float32[] f_VrelYStd\n"
"float32[] f_ArelXStd\n"
"float32[] f_ArelYStd\n"
"float32[] f_LDeltaX_left\n"
"float32[] f_LDeltaX_mid\n"
"float32[] f_LDeltaX_right\n"
"float32[] f_LDeltaY_left\n"
"\n"
"float32[] f_LDeltaY_mid\n"
"float32[] f_LDeltaY_right\n"
"float32[] f_RCS\n"
"float32[] f_ObjectScore\n"
"float32[] f_VabsX\n"
"float32[] f_VabsY\n"
"float32[] f_AabsX\n"
"float32[] f_AabsY\n"
"float32[] f_VabsXStd\n"
"float32[] f_VabsYStd\n"
"float32[] f_AabsXStd\n"
"float32[] f_AabsYStd\n"
"\n"
"float32[] f_Orientation\n"
"float32[] f_OrientationStd\n"
"float32[] f_DistZ\n"
"float32[] f_DistZStd\n"
;
  }

  static const char* value(const ::conti_radar::radar_obj_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::conti_radar::radar_obj_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.f_DistX);
      stream.next(m.f_DistY);
      stream.next(m.f_VrelX);
      stream.next(m.f_VrelY);
      stream.next(m.f_ArelX);
      stream.next(m.f_ArelY);
      stream.next(m.f_DistXStd);
      stream.next(m.f_DistYStd);
      stream.next(m.f_VrelXStd);
      stream.next(m.f_VrelYStd);
      stream.next(m.f_ArelXStd);
      stream.next(m.f_ArelYStd);
      stream.next(m.f_LDeltaX_left);
      stream.next(m.f_LDeltaX_mid);
      stream.next(m.f_LDeltaX_right);
      stream.next(m.f_LDeltaY_left);
      stream.next(m.f_LDeltaY_mid);
      stream.next(m.f_LDeltaY_right);
      stream.next(m.f_RCS);
      stream.next(m.f_ObjectScore);
      stream.next(m.f_VabsX);
      stream.next(m.f_VabsY);
      stream.next(m.f_AabsX);
      stream.next(m.f_AabsY);
      stream.next(m.f_VabsXStd);
      stream.next(m.f_VabsYStd);
      stream.next(m.f_AabsXStd);
      stream.next(m.f_AabsYStd);
      stream.next(m.f_Orientation);
      stream.next(m.f_OrientationStd);
      stream.next(m.f_DistZ);
      stream.next(m.f_DistZStd);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct radar_obj_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::conti_radar::radar_obj_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::conti_radar::radar_obj_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id);
    s << indent << "f_DistX[]" << std::endl;
    for (size_t i = 0; i < v.f_DistX.size(); ++i)
    {
      s << indent << "  f_DistX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistX[i]);
    }
    s << indent << "f_DistY[]" << std::endl;
    for (size_t i = 0; i < v.f_DistY.size(); ++i)
    {
      s << indent << "  f_DistY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistY[i]);
    }
    s << indent << "f_VrelX[]" << std::endl;
    for (size_t i = 0; i < v.f_VrelX.size(); ++i)
    {
      s << indent << "  f_VrelX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VrelX[i]);
    }
    s << indent << "f_VrelY[]" << std::endl;
    for (size_t i = 0; i < v.f_VrelY.size(); ++i)
    {
      s << indent << "  f_VrelY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VrelY[i]);
    }
    s << indent << "f_ArelX[]" << std::endl;
    for (size_t i = 0; i < v.f_ArelX.size(); ++i)
    {
      s << indent << "  f_ArelX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_ArelX[i]);
    }
    s << indent << "f_ArelY[]" << std::endl;
    for (size_t i = 0; i < v.f_ArelY.size(); ++i)
    {
      s << indent << "  f_ArelY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_ArelY[i]);
    }
    s << indent << "f_DistXStd[]" << std::endl;
    for (size_t i = 0; i < v.f_DistXStd.size(); ++i)
    {
      s << indent << "  f_DistXStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistXStd[i]);
    }
    s << indent << "f_DistYStd[]" << std::endl;
    for (size_t i = 0; i < v.f_DistYStd.size(); ++i)
    {
      s << indent << "  f_DistYStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistYStd[i]);
    }
    s << indent << "f_VrelXStd[]" << std::endl;
    for (size_t i = 0; i < v.f_VrelXStd.size(); ++i)
    {
      s << indent << "  f_VrelXStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VrelXStd[i]);
    }
    s << indent << "f_VrelYStd[]" << std::endl;
    for (size_t i = 0; i < v.f_VrelYStd.size(); ++i)
    {
      s << indent << "  f_VrelYStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VrelYStd[i]);
    }
    s << indent << "f_ArelXStd[]" << std::endl;
    for (size_t i = 0; i < v.f_ArelXStd.size(); ++i)
    {
      s << indent << "  f_ArelXStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_ArelXStd[i]);
    }
    s << indent << "f_ArelYStd[]" << std::endl;
    for (size_t i = 0; i < v.f_ArelYStd.size(); ++i)
    {
      s << indent << "  f_ArelYStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_ArelYStd[i]);
    }
    s << indent << "f_LDeltaX_left[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaX_left.size(); ++i)
    {
      s << indent << "  f_LDeltaX_left[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaX_left[i]);
    }
    s << indent << "f_LDeltaX_mid[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaX_mid.size(); ++i)
    {
      s << indent << "  f_LDeltaX_mid[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaX_mid[i]);
    }
    s << indent << "f_LDeltaX_right[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaX_right.size(); ++i)
    {
      s << indent << "  f_LDeltaX_right[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaX_right[i]);
    }
    s << indent << "f_LDeltaY_left[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaY_left.size(); ++i)
    {
      s << indent << "  f_LDeltaY_left[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaY_left[i]);
    }
    s << indent << "f_LDeltaY_mid[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaY_mid.size(); ++i)
    {
      s << indent << "  f_LDeltaY_mid[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaY_mid[i]);
    }
    s << indent << "f_LDeltaY_right[]" << std::endl;
    for (size_t i = 0; i < v.f_LDeltaY_right.size(); ++i)
    {
      s << indent << "  f_LDeltaY_right[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_LDeltaY_right[i]);
    }
    s << indent << "f_RCS[]" << std::endl;
    for (size_t i = 0; i < v.f_RCS.size(); ++i)
    {
      s << indent << "  f_RCS[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_RCS[i]);
    }
    s << indent << "f_ObjectScore[]" << std::endl;
    for (size_t i = 0; i < v.f_ObjectScore.size(); ++i)
    {
      s << indent << "  f_ObjectScore[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_ObjectScore[i]);
    }
    s << indent << "f_VabsX[]" << std::endl;
    for (size_t i = 0; i < v.f_VabsX.size(); ++i)
    {
      s << indent << "  f_VabsX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VabsX[i]);
    }
    s << indent << "f_VabsY[]" << std::endl;
    for (size_t i = 0; i < v.f_VabsY.size(); ++i)
    {
      s << indent << "  f_VabsY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VabsY[i]);
    }
    s << indent << "f_AabsX[]" << std::endl;
    for (size_t i = 0; i < v.f_AabsX.size(); ++i)
    {
      s << indent << "  f_AabsX[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_AabsX[i]);
    }
    s << indent << "f_AabsY[]" << std::endl;
    for (size_t i = 0; i < v.f_AabsY.size(); ++i)
    {
      s << indent << "  f_AabsY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_AabsY[i]);
    }
    s << indent << "f_VabsXStd[]" << std::endl;
    for (size_t i = 0; i < v.f_VabsXStd.size(); ++i)
    {
      s << indent << "  f_VabsXStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VabsXStd[i]);
    }
    s << indent << "f_VabsYStd[]" << std::endl;
    for (size_t i = 0; i < v.f_VabsYStd.size(); ++i)
    {
      s << indent << "  f_VabsYStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_VabsYStd[i]);
    }
    s << indent << "f_AabsXStd[]" << std::endl;
    for (size_t i = 0; i < v.f_AabsXStd.size(); ++i)
    {
      s << indent << "  f_AabsXStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_AabsXStd[i]);
    }
    s << indent << "f_AabsYStd[]" << std::endl;
    for (size_t i = 0; i < v.f_AabsYStd.size(); ++i)
    {
      s << indent << "  f_AabsYStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_AabsYStd[i]);
    }
    s << indent << "f_Orientation[]" << std::endl;
    for (size_t i = 0; i < v.f_Orientation.size(); ++i)
    {
      s << indent << "  f_Orientation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_Orientation[i]);
    }
    s << indent << "f_OrientationStd[]" << std::endl;
    for (size_t i = 0; i < v.f_OrientationStd.size(); ++i)
    {
      s << indent << "  f_OrientationStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_OrientationStd[i]);
    }
    s << indent << "f_DistZ[]" << std::endl;
    for (size_t i = 0; i < v.f_DistZ.size(); ++i)
    {
      s << indent << "  f_DistZ[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistZ[i]);
    }
    s << indent << "f_DistZStd[]" << std::endl;
    for (size_t i = 0; i < v.f_DistZStd.size(); ++i)
    {
      s << indent << "  f_DistZStd[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.f_DistZStd[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // CONTI_RADAR_MESSAGE_RADAR_OBJ_H
